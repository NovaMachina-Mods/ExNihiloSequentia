import net.darkhax.curseforgegradle.TaskPublishCurseForge
import net.darkhax.curseforgegradle.UploadArtifact
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

buildscript {
    dependencies {
        classpath "com.diffplug.spotless:spotless-plugin-gradle:6.8.0"
    }
}

plugins {
    id 'java'
    id 'idea'
    id 'eclipse'
    id 'maven-publish'
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
    id 'net.darkhax.curseforgegradle' version '1.0.11'
    id 'org.ajoberstar.grgit' version '4.1.1'
    id 'org.barfuin.gradle.taskinfo' version '2.1.0'
    id "se.bjurr.gitchangelog.git-changelog-gradle-plugin" version "1.79.0"
}

if(!System.getenv('CI')) {
    apply plugin: 'com.diffplug.spotless'
    spotless {
        ratchetFrom 'origin/1.19'
        format 'misc', {
            target '*.gradle', '*.md', '.gitignore'

            trimTrailingWhitespace()
            indentWithSpaces(2)
            endWithNewline()
        }
        java {
            removeUnusedImports()
            trimTrailingWhitespace()
            googleJavaFormat()
        }
    }
}

if(project.tasks.findByName("wrapper") == null) {
    task wrapper(type: Wrapper) {
        gradleVersion = '7.6'
        distributionType = Wrapper.DistributionType.ALL
    }
}

ext {
    modsTomlProperties = ["version"                 : "${property("modVersion")}",
                          "mc_version"               : "[${minecraftRelease},)",
                          "forge_version"            : "[${property("forgeVersion")},)",
                          "loader_version"           : "[${forgeMajor},)",
                          "git_url"                  : "${property("gitUrl")}",
                          "curseforge_url"           : "${property("curseForgeUrl")}",
                          "crafttweaker_version"     : "[${property("crafttweakerVersion")},)",
                          "jei_version"              : "[${property("jeiVersion")},)",]
    jsonPatterns = ["**/*.json", "**/*.mcmeta"]
}

String basicVersion = "${property("modVersion")}." + (System.getenv("GITHUB_RUN_NUMBER") ?: "homebaked")
version = "${property("minecraftVersion")}-${basicVersion}" + (property("releaseType") != 'release' ? "-${property("releaseType")}" : '')
group = "novamachina.${project.name.toLowerCase()}"
archivesBaseName = property("artifactBasename")

String minecraftRelease = getMinecraftRelease()
String forgeMajor = getForgeMajor()

defaultTasks 'build'

task installLocalGitHook(type: Copy) {
    group = "management"
    description = "Installs git hooks into their proper location"

    String hooksDir = '.git/hooks'
    if(file("${projectDir}/.git").isFile()) {
        String fileContents = new File(projectDir, '.git').text
        hooksDir = "${fileContents.split(": ")[1].dropRight(1)}/hooks"
    }

    from new File(projectDir, 'scripts/pre-commit')
    into { new File(hooksDir)}
    fileMode 0775
}

build.dependsOn installLocalGitHook

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"
minecraft {
    mappings channel: property("mappingsChannel"), version: property("mappingsVersion")

    // accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg') // Currently, this location cannot be changed from the default.

    runs {
        client {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', "${project.name.toLowerCase()}"
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${project.name}" {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', "${project.name.toLowerCase()}"
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${project.name}" {
                    source sourceSets.main
                }
            }
        }

        gameTestServer {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', "${project.name.toLowerCase()}"
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${project.name}" {
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            args '--mod', "${project.name.toLowerCase()}", '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

            mods {
                "${project.name}" {
                    source sourceSets.main
                }
            }
        }
    }
}

sourceSets.main.resources { srcDir 'src/generated/resources' }

repositories {
    //moved from progwml6 to blamejared's repo (for future updates)
    //maven {
    //    name 'prog'
    //    url 'https://dvs1.progwml6.com/files/maven'
    //    content {
    //        includeGroup 'mezz.jei'
    //    }
    //}
    maven {
        name 'CraftTweaker'
        url "https://maven.blamejared.com"
        content {
            includeGroup 'com.blamejared.crafttweaker'
            includeGroup 'org.openzen.zencode'
            includeGroup 'mezz.jei'
        }
    }
    maven {
        name 'k-4u'
        url 'https://maven.k-4u.nl/'
        content {
            includeGroup 'mcjty.theoneprobe'
        }
    }
    maven {
        name 'CurseMaven'
        url 'https://www.cursemaven.com'
        content {
            includeGroup 'curse.maven'
        }
    }
    maven {
        url 'https://maven.architectury.dev'
        content {
            includeGroup 'dev.architectury'
        }
    }
    maven {
        url 'https://maven.saps.dev/minecraft'
        content {
            includeGroup 'dev.latvian.mods'
        }
    }

    whenObjectAdded {
        if (it instanceof MavenArtifactRepository) {
            def url = it.url.toString()
            if (url == 'https://maven.minecraftforge.net/' || url == 'https://libraries.minecraft.net/' || url == 'https://repo.maven.apache.org/maven2/') {
                try {
                    it.content {
                        excludeGroup 'curse.maven'
                        excludeGroup 'mezz.jei'
                        excludeGroup 'mcjty.theoneprobe'
                        excludeGroup 'com.blamejared.crafttweaker'
                        excludeGroup 'dev.architectury'
                        excludeGroup 'dev.latvian.mods'
                    }
                    println("Adding exclusions to ${it.url}")
                } catch (Exception ignored) {
                    //oh well
                }
            }
        }
    }
}

dependencies {
    minecraft "net.minecraftforge:forge:${property("minecraftVersion")}-${property("forgeVersion")}"

    compileOnly fg.deobf("mezz.jei:jei-${property("minecraftVersion")}-forge-api:${property("jeiVersion")}")
    implementation fg.deobf("mezz.jei:jei-${property("minecraftVersion")}-forge:${property("jeiVersion")}")

    compileOnly fg.deobf("mcjty.theoneprobe:theoneprobe:${minecraftRelease}-${property("topVersion")}:api") {
        transitive = false
    }
    runtimeOnly fg.deobf("mcjty.theoneprobe:theoneprobe:${minecraftRelease}-${property("topVersion")}") {
        transitive = false
    }

    compileOnly fg.deobf("curse.maven:jade-api-324717:${property("jadeApiId")}")
//        runtimeOnly fg.deobf("curse.maven:jade-324717:${property("jadeId")}")

    implementation fg.deobf("com.blamejared.crafttweaker:CraftTweaker-forge-${property("minecraftVersion")}:${property("crafttweakerVersion")}")
    annotationProcessor 'com.blamejared.crafttweaker:Crafttweaker_Annotation_Processors:3.0.0.10'
    annotationProcessor "net.minecraftforge:forge:${property("minecraftVersion")}-${property("forgeVersion")}"
    annotationProcessor "com.blamejared.crafttweaker:CraftTweaker-forge-${property("minecraftVersion")}:${property("crafttweakerVersion")}"

    implementation fg.deobf("dev.latvian.mods:kubejs-forge:${property("kubejsVersion")}")
    implementation fg.deobf("dev.latvian.mods:rhino-forge:${property("rhinoVersion")}")
    implementation fg.deobf("dev.architectury:architectury-forge:${property("architecturyVersion")}")
}

String projectProperName = property("projectProperName")

jar {
    manifest {
        attributes([
                "Specification-Title"     : projectProperName,
                "Specification-Vendor"    : "NovaMachina",
                "Specification-Version"   : "${modVersion}",
                "Implementation-Title"    : projectProperName,
                "Implementation-Version"  : "${modVersion}",
                "Implementation-Vendor"   : "NovaMachina",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

// Example configuration to allow publishing using the maven-publish plugin
// This is the preferred method to reobfuscate your jar file
//jar.finalizedBy('reobfJar')
// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
publish.dependsOn('reobfJar')

tasks.withType(GenerateModuleMetadata) {
    // Disable Gradle 7 module metadata generation as it does not play nicely with FG
    enabled = false
}

publishing {
    publications { PublicationContainer publicationContainer ->
        publicationContainer.register("main", MavenPublication) { MavenPublication publication ->
            publication.from((SoftwareComponent) components.java)
            publication.groupId = project.group
            publication.version = project.version
            publication.artifactId = System.getenv("MAVEN_ARTIFACT") ?: project.archivesBaseName
            publication.artifacts = [jar]
            publication.pom {
                name.set("${property("projectProperName")}")
                packaging = 'jar'
                description.set("${property("projectDescription")}")
                url.set("${property("curseForgeUrl")}")
                scm {
                    url.set("${property("gitUrl")}.git")
                }
                issueManagement {
                    system.set('github')
                    url.set("${property("gitUrl")}/issues")
                }
                licenses {
                    license {
                        name.set('Creative Commons')
                        distribution.set('repo')
                    }
                }
                withXml {
                    NodeList dependencies = asNode().dependencies
                    NodeList allDeps = dependencies.'*'

                    // Remove forge deps
                    allDeps.<Node> findAll() { Node el ->
                        el.artifactId.text() == 'forge' && el.groupId.text() == 'net.minecraftforge'
                    }.forEach() { Node el ->
                        el.parent().remove(el)
                    }
                    //remove ForgeGradle's mapped suffix from versions & set as optional so anyone else doesn't inherit them
                    allDeps.<Node> findAll() { Node el ->
                        el.version.text().contains('_mapped_')
                    }.each { Node el ->
                        el.version.each { Node version ->
                            def versionText = version.text()
                            version.setValue(versionText.substring(0, versionText.indexOf('_mapped_')))
                        }
                        el.appendNode('optional', true)
                    }
                }
            }
        }
    }
    repositories {
        maven {
            name = "cloudsmith"
            url = "https://maven.cloudsmith.io/novamachina-mods/ex-nihilo-sequentia/"
            credentials {
                username = System.getenv("MAVEN_USERNAME")
                password = System.getenv("MAVEN_PASSWORD")
            }
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

task replaceResources(type: Copy) {
    it.outputs.upToDateWhen { false }
    def modsToml = copySpec {
        from(sourceSets.main.resources) {
            include "META-INF/mods.toml"
            expand modsTomlProperties
        }
    }
    it.with modsToml
    it.into "$buildDir/resources/main/"
    if (new File("$rootDir/out/production/${project.name}.main/").exists()) {
        copy {
            with modsToml
            into "$rootDir/out/production/${project.name}.main/"
        }
    }
    if (new File("$rootDir/bin/main/").exists()) {
        copy {
            with modsToml
            into "$rootDir/bin/main/"
        }
    }
}

processResources {
    duplicatesStrategy(DuplicatesStrategy.FAIL)
    exclude('META-INF/mods.toml')
    from(projectDir) {
        include "logo.png"
    }
    configure {
        finalizedBy {
            replaceResources
        }
    }
    doLast {
        fileTree(dir: getOutputs().getFiles().getAsPath(), includes: jsonPatterns).each {
            File file -> file.setText(JsonOutput.toJson(new JsonSlurper().parse(file)))
        }
    }
}

classes {
    configure {
        dependsOn {
            replaceResources
        }
    }
}

compileJava {
    options.compilerArgs << "-Acrafttweaker.processor.document.output_directory=${file('docsOut')}"
    options.getGeneratedSourceOutputDirectory().set(file("src/main/resources/"))
}

String getMinecraftRelease() {
    String value = property("minecraftVersion")
    String[] values = value.split("\\.")
    return "${values[0]}.${values[1]}"
}

String getForgeMajor() {
    String value = property("forgeVersion")
    String[] values = value.split("\\.")
    return "${values[0]}"
}

String resolvedChangelog = null

def changeLogResolver = { ->
    if(resolvedChangelog != null) {
        return resolvedChangelog
    }
    String generatedChangelog = "Unable to generate changelog :("
    String currentCommit = System.getenv("GITHUB_SHA")
    String prevCommit = property('changelogStartCommit')

    if (currentCommit != null && prevCommit != null) {
        generatedChangelog = ""
        grgit.log {
            range(prevCommit, currentCommit)
        }.reverse().each { commit ->
            // Use full message rather than short message to get any new lines, and trim it so that any trailing new lines
            // get removed so that we don't end up with extra spaces
            String message = commit.fullMessage.trim()
            if (!message.startsWith("Merge branch") && !message.startsWith("Merge pull request")) {
                //Ignore Merges and PR Merges
                message = message.replaceAll("#(\\d+)", { match ->// turn issues/prs into links (github currently supports prs being linked as issues)
                    return "<a href=\"${property("gitUrl")}/issues/${match[1]}\">${match[0]}</a>"
                } as String).replaceAll("\\n", "<br>&emsp;")
                // convert new lines that are part of a commit message into actual new lines and a tab
                if (generatedChangelog != "") {
                    // If this isn't the first commit prepend an extra newline
                    generatedChangelog += "<br>"
                }
                generatedChangelog += "<a href=\"${property("gitUrl")}/commit/${commit.id}\">${commit.getAbbreviatedId()}</a> - ${message}"
            }
        }
        println "Changelog generated"
    }

    File releaseNotesFile = project.file("docs/release_${modVersion}.html")
    if (releaseNotesFile.exists()) {
        // Add any version specific changelog stuff
        def releaseNotes = releaseNotesFile.getText()
        generatedChangelog = "$releaseNotes<br> $generatedChangelog"
    }

    if (property("releaseType") == "alpha") {
        // Add a warning at the top about what an alpha build means
        generatedChangelog = "Warning: ${property("projectProperName")} is currently in alpha, and is not recommended for widespread use in modpacks. There are likely to be game breaking bugs, " +
                "and updating from one alpha to the next may cause various ${property("projectProperName")} blocks and items to disappear/void their contents. While we will try to not have this " +
                "happen/keep it to a minimum make sure to make backups. <br> $generatedChangelog"
    }
    if (property("releaseType") == "beta") {
        // Add a warning at the top about what an beta build means
        generatedChangelog = "Warning: ${property("projectProperName")} is currently in beta, and is not recommended for widespread use in modpacks. There may be game breaking bugs, " +
                "and updating from one beta to the next may cause various ${property("projectProperName")} blocks and items to disappear/void their contents. " +
                "While this is unlikely to happen in a beta, make sure to make backups. <br> $generatedChangelog"
    }
    resolvedChangelog = generatedChangelog
    return generatedChangelog
}

task publishCurseForge(type: TaskPublishCurseForge) {
    group = "publishing"
    description = "Publishes project to CurseForge"

    apiToken = System.getenv("CURSEFORGE_KEY")
    String projectId = project.property("curseForgeId")

    UploadArtifact mainFile = upload(projectId, jar)
    mainFile.releaseType = project.property("releaseType")
    mainFile.changelogType = 'html'
    mainFile.changelog = changeLogResolver.call()
    mainFile.addModLoader("Forge")
    mainFile.addGameVersion(project.property("minecraftVersion"))
    mainFile.addOptional("jade")
    mainFile.addOptional("jei")
    mainFile.addOptional("the-one-probe")
}

publishCurseForge.dependsOn('reobfJar')

if(rootProject.name != project.name) {
    task updateToolingProperties(type: WriteProperties) {
        group = "management"
        description = "Updates tooling properties for all sub-projects"

        outputs.upToDateWhen {
            false
        }

        outputFile("gradle.properties")

        doFirst {
            def currentProps = getProps(file("gradle.properties"))
            def rootProps = getProps(file("$rootDir/gradle.properties"))

            rootProps.forEach((key, value) -> {
                if (currentProps.containsKey(key)) {
                    currentProps.put(key, value)
                }
            })

            properties(currentProps)
        }

        comment('''This file may have been edited by a Gradle Task.

A note on the 'modVersion' property
Version pattern: MAJOR.MINOR.PATCH
Update MAJORMOD when mod objects (items, blocks, block entities) are removed, fundamental mechanics are changed, or backwards compatibility is broken.
Update MINOR when mod objects (items, blocks, block entities) or non-fundamental mechanics are added, or elements of the API are deprecated (but not removed)
PATCH will automatically be created by GitVersion

The value in gradle.properties is only used in local development''')
    }
}

Map<String, Object> getProps(File propFile) {
    Map<String, Object> mappedProps = new HashMap<>()
    Properties props = new Properties()
    if (propFile.canRead()) {
        props.load(new FileInputStream(propFile))
        props.forEach((key, value) -> {
            mappedProps.put(key as String, value)
        })
    }
    return mappedProps
}

task makeChangelog(type: se.bjurr.gitchangelog.plugin.gradle.GitChangelogTask) {
    file = new File ("changelog.html")
    untaggedName = "Current release ${project.version}"
    fromCommit = System.getenv("GIT_PREVIOUS_SUCCESSFUL_COMMIT")
    toRef =  "HEAD"
    gitHubIssuePattern = "nonada123";
    templateContent = """
{{#tags}}
    <h3>{{name}}</h3>
    <ul>
        {{#commits}}
            <li>
                <a href="https://github.com/NovaMachina-Mods/ExNihiloSequentia/commit/{{hashFull}}">{{{messageTitle}}}</a> - {{{authorName}}}
                <ul>
                    {{#messageBodyItems}}
                        <li>{{.}}</li>
                    {{/messageBodyItems}}
                </ul>
            </li>
        {{/commits}}
    </ul>
{{/tags}}
"""
}