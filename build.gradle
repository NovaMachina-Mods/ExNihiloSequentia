import net.darkhax.curseforgegradle.TaskPublishCurseForge
import net.darkhax.curseforgegradle.UploadArtifact
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import se.bjurr.gitchangelog.plugin.gradle.GitChangelogTask

buildscript {
    dependencies {
        classpath "com.diffplug.spotless:spotless-plugin-gradle:6.8.0"
    }
}

plugins {
    id 'java'
    id 'idea'
    id 'eclipse'
    id 'maven-publish'
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
    id 'net.darkhax.curseforgegradle' version '1.0.11'
    id 'com.modrinth.minotaur' version "2.+"
    id 'org.ajoberstar.grgit' version '5.2.0'
    id 'org.barfuin.gradle.taskinfo' version '2.1.0'
    id "se.bjurr.gitchangelog.git-changelog-gradle-plugin" version "1.79.0"
}

if(!System.getenv('CI')) {
    apply plugin: 'com.diffplug.spotless'
    spotless {
        ratchetFrom 'origin/1.19'
        format 'misc', {
            target '*.gradle', '*.md', '.gitignore'

            trimTrailingWhitespace()
            indentWithSpaces(2)
            endWithNewline()
        }
        java {
            removeUnusedImports()
            trimTrailingWhitespace()
            googleJavaFormat()
        }
    }
}

if(project.tasks.findByName("wrapper") == null) {
    task wrapper(type: Wrapper) {
        gradleVersion = '7.6'
        distributionType = Wrapper.DistributionType.ALL
    }
}

ext {
    modsTomlProperties = [
            "version" : "${property("modVersion")}",
            "mc_version" : "[${minecraftRelease},)",
            "forge_version" : "[${property("forgeVersion")},)",
            "loader_version" : "[${forgeMajor},)",
            "git_url" : "${property("gitUrl")}",
            "curseforge_url" : "${property("curseForgeUrl")}",
            "crafttweaker_version" : "[${property("crafttweakerVersion")},)",
            "jei_version" : "[${property("jeiVersion")},)"
    ]
    jsonPatterns = ["**/*.json", "**/*.mcmeta"]
}

String basicVersion = "${property("modVersion")}." + (System.getenv("GITHUB_RUN_NUMBER") ?: "homebaked")
version = "${property("minecraftVersion")}-${basicVersion}" + (property("releaseType") != 'release' ? "-${property("releaseType")}" : '')
group = "novamachina.${project.name.toLowerCase()}"
archivesBaseName = property("artifactBasename")

String minecraftRelease = getMinecraftRelease()
String forgeMajor = getForgeMajor()

defaultTasks 'build'

task installLocalGitHook(type: Copy) {
    group = "management"
    description = "Installs git hooks into their proper location"

    String hooksDir = '.git/hooks'
    if(file("${projectDir}/.git").isFile()) {
        String fileContents = new File(projectDir, '.git').text
        hooksDir = "${fileContents.split(": ")[1].dropRight(1)}/hooks"
    }

    from new File(projectDir, 'scripts/pre-commit')
    into { new File(hooksDir)}
    fileMode 0775
}

build.dependsOn installLocalGitHook

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

println("Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}")
minecraft {
    mappings channel: property("mappingsChannel"), version: property("mappingsVersion")

    // accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg') // Currently, this location cannot be changed from the default.

    runs {
        client {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', "${project.name.toLowerCase()}"
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${project.name}" {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', "${project.name.toLowerCase()}"
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${project.name}" {
                    source sourceSets.main
                }
            }
        }

        gameTestServer {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', "${project.name.toLowerCase()}"
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${project.name}" {
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            args '--mod', "${project.name.toLowerCase()}", '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

            mods {
                "${project.name}" {
                    source sourceSets.main
                }
            }
        }
    }
}

sourceSets.main.resources { srcDir 'src/generated/resources' }

repositories {
    //moved from progwml6 to blamejared's repo (for future updates)
    //maven {
    //    name 'prog'
    //    url 'https://dvs1.progwml6.com/files/maven'
    //    content {
    //        includeGroup 'mezz.jei'
    //    }
    //}
    maven {
        name 'CraftTweaker'
        url "https://maven.blamejared.com"
        content {
            includeGroup 'com.blamejared.crafttweaker'
            includeGroup 'org.openzen.zencode'
            includeGroup 'mezz.jei'
        }
    }
    maven {
        name 'k-4u'
        url 'https://maven.k-4u.nl/'
        content {
            includeGroup 'mcjty.theoneprobe'
        }
    }
    maven {
        name 'CurseMaven'
        url 'https://www.cursemaven.com'
        content {
            includeGroup 'curse.maven'
        }
    }
    maven {
        url 'https://maven.architectury.dev'
        content {
            includeGroup 'dev.architectury'
        }
    }
    maven {
        url 'https://maven.saps.dev/minecraft'
        content {
            includeGroup 'dev.latvian.mods'
        }
    }

    whenObjectAdded {
        if (it instanceof MavenArtifactRepository) {
            def url = it.url.toString()
            if (url == 'https://maven.minecraftforge.net/' || url == 'https://libraries.minecraft.net/' || url == 'https://repo.maven.apache.org/maven2/') {
                try {
                    it.content {
                        excludeGroup 'curse.maven'
                        excludeGroup 'mezz.jei'
                        excludeGroup 'mcjty.theoneprobe'
                        excludeGroup 'com.blamejared.crafttweaker'
                        excludeGroup 'dev.architectury'
                        excludeGroup 'dev.latvian.mods'
                    }
                    logger.info("Adding exclusions to ${it.url}")
                } catch (Exception ignored) {
                    //oh well
                }
            }
        }
    }
}

dependencies {
    minecraft "net.minecraftforge:forge:${property("minecraftVersion")}-${property("forgeVersion")}"

    compileOnly fg.deobf("mezz.jei:jei-${property("minecraftVersion")}-forge-api:${property("jeiVersion")}")
    implementation fg.deobf("mezz.jei:jei-${property("minecraftVersion")}-forge:${property("jeiVersion")}")

    compileOnly fg.deobf("mcjty.theoneprobe:theoneprobe:${minecraftRelease}-${property("topVersion")}:api") {
        transitive = false
    }
    runtimeOnly fg.deobf("mcjty.theoneprobe:theoneprobe:${minecraftRelease}-${property("topVersion")}") {
        transitive = false
    }

    compileOnly fg.deobf("curse.maven:jade-api-324717:${property("jadeApiId")}")
//        runtimeOnly fg.deobf("curse.maven:jade-324717:${property("jadeId")}")

    implementation fg.deobf("com.blamejared.crafttweaker:CraftTweaker-forge-${property("minecraftVersion")}:${property("crafttweakerVersion")}")
    annotationProcessor 'com.blamejared.crafttweaker:Crafttweaker_Annotation_Processors:3.0.0.10'
    annotationProcessor "net.minecraftforge:forge:${property("minecraftVersion")}-${property("forgeVersion")}"
    annotationProcessor "com.blamejared.crafttweaker:CraftTweaker-forge-${property("minecraftVersion")}:${property("crafttweakerVersion")}"

    implementation fg.deobf("dev.latvian.mods:kubejs-forge:${property("kubejsVersion")}")
    implementation fg.deobf("dev.latvian.mods:rhino-forge:${property("rhinoVersion")}")
    implementation fg.deobf("dev.architectury:architectury-forge:${property("architecturyVersion")}")
}

String projectProperName = property("projectProperName")

jar {
    manifest {
        attributes([
                "Specification-Title"     : projectProperName,
                "Specification-Vendor"    : "NovaMachina",
                "Specification-Version"   : "${modVersion}",
                "Implementation-Title"    : projectProperName,
                "Implementation-Version"  : "${modVersion}",
                "Implementation-Vendor"   : "NovaMachina",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

// Example configuration to allow publishing using the maven-publish plugin
// This is the preferred method to reobfuscate your jar file
//jar.finalizedBy('reobfJar')
// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
publish.dependsOn('reobfJar')

tasks.withType(GenerateModuleMetadata) {
    // Disable Gradle 7 module metadata generation as it does not play nicely with FG
    enabled = false
}

publishing {
    publications { PublicationContainer publicationContainer ->
        publicationContainer.register("main", MavenPublication) { MavenPublication publication ->
            publication.from((SoftwareComponent) components.java)
            publication.groupId = project.group
            publication.version = project.version
            publication.artifactId = System.getenv("MAVEN_ARTIFACT") ?: project.archivesBaseName
            publication.artifacts = [jar]
            publication.pom {
                name.set("${property("projectProperName")}")
                packaging = 'jar'
                description.set("${property("projectDescription")}")
                url.set("${property("curseForgeUrl")}")
                scm {
                    url.set("${property("gitUrl")}.git")
                }
                issueManagement {
                    system.set('github')
                    url.set("${property("gitUrl")}/issues")
                }
                licenses {
                    license {
                        name.set('Creative Commons')
                        distribution.set('repo')
                    }
                }
                withXml {
                    NodeList dependencies = asNode().dependencies
                    NodeList allDeps = dependencies.'*'

                    // Remove forge deps
                    allDeps.<Node> findAll() { Node el ->
                        el.artifactId.text() == 'forge' && el.groupId.text() == 'net.minecraftforge'
                    }.forEach() { Node el ->
                        el.parent().remove(el)
                    }
                    //remove ForgeGradle's mapped suffix from versions & set as optional so anyone else doesn't inherit them
                    allDeps.<Node> findAll() { Node el ->
                        el.version.text().contains('_mapped_')
                    }.each { Node el ->
                        el.version.each { Node version ->
                            def versionText = version.text()
                            version.setValue(versionText.substring(0, versionText.indexOf('_mapped_')))
                        }
                        el.appendNode('optional', true)
                    }
                }
            }
        }
    }
    repositories {
        maven {
            name = "cloudsmith"
            url = "https://maven.cloudsmith.io/novamachina-mods/ex-nihilo-sequentia/"
            credentials {
                username = System.getenv("MAVEN_USERNAME")
                password = System.getenv("MAVEN_PASSWORD")
            }
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

task replaceResources(type: Copy) {
    it.outputs.upToDateWhen { false }
    def modsToml = copySpec {
        from(sourceSets.main.resources) {
            include "META-INF/mods.toml"
            expand modsTomlProperties
        }
    }
    it.with modsToml
    it.into "$buildDir/resources/main/"
    if (new File("$rootDir/out/production/${project.name}.main/").exists()) {
        copy {
            with modsToml
            into "$rootDir/out/production/${project.name}.main/"
        }
    }
    if (new File("$rootDir/bin/main/").exists()) {
        copy {
            with modsToml
            into "$rootDir/bin/main/"
        }
    }
}

processResources {
    duplicatesStrategy(DuplicatesStrategy.FAIL)
    exclude('META-INF/mods.toml')
    from(projectDir) {
        include "logo.png"
    }
    configure {
        finalizedBy {
            replaceResources
        }
    }
    doLast {
        fileTree(dir: getOutputs().getFiles().getAsPath(), includes: jsonPatterns).each {
            File file -> file.setText(JsonOutput.toJson(new JsonSlurper().parse(file)))
        }
    }
}

classes {
    configure {
        dependsOn {
            replaceResources
        }
    }
}

compileJava {
    options.compilerArgs << "-Acrafttweaker.processor.document.output_directory=${file('docsOut')}"
    options.getGeneratedSourceOutputDirectory().set(file("src/main/resources/"))
}

String getMinecraftRelease() {
    String value = property("minecraftVersion")
    String[] values = value.split("\\.")
    return "${values[0]}.${values[1]}"
}

String getForgeMajor() {
    String value = property("forgeVersion")
    String[] values = value.split("\\.")
    return "${values[0]}"
}

task publishCurseForge(type: TaskPublishCurseForge) {
    group = "publishing"
    description = "Publishes project to CurseForge"

    apiToken = System.getenv("CURSEFORGE_KEY")
    String projectId = project.property("curseForgeId")

    UploadArtifact mainFile = upload(projectId, jar)
    mainFile.releaseType = project.property("releaseType")
    mainFile.changelogType = 'html'
    mainFile.changelog = (file('changelog.html').exists() ? file('changelog.html').text : "No changelog was specified.")
    mainFile.addModLoader("Forge")
    mainFile.addGameVersion(project.property("minecraftVersion"))
    mainFile.addOptional("jade")
    mainFile.addOptional("jei")
    mainFile.addOptional("the-one-probe")
}

publishCurseForge.dependsOn('reobfJar')
publishCurseForge.dependsOn('makeChangelogHtml')

modrinth {
    token = System.getenv("MODRINTH_TOKEN")
    projectId = "${project.property("modrinthProjectId")}"
    uploadFile = jar
    versionType = "${project.property("releaseType")}"
    gameVersions = ["${project.property("minecraftVersion")}"]
    loaders = ["forge"]
    changelog = (file('changelog.md').exists() ? file('changelog.md').text : DEFAULT_CHANGELOG)
    dependencies {
        optional.project "jade"
        optional.project "jei"
        optional.project "the-one-probe"
    }
}

//tasks.named("modrinth") {
//    dependsOn('reobfJar')
//}
tasks.named("modrinth") {
    dependsOn('makeChangelogMd')
}

if(rootProject.name != project.name) {
    task updateToolingProperties(type: WriteProperties) {
        group = "management"
        description = "Updates tooling properties for all sub-projects"

        outputs.upToDateWhen {
            false
        }

        outputFile("gradle.properties")

        doFirst {
            def currentProps = getProps(file("gradle.properties"))
            def rootProps = getProps(file("$rootDir/gradle.properties"))

            rootProps.forEach((key, value) -> {
                if (currentProps.containsKey(key)) {
                    currentProps.put(key, value)
                }
            })

            properties(currentProps)
        }

        comment('''This file may have been edited by a Gradle Task.

A note on the 'modVersion' property
Version pattern: MAJORMOD.MAJORAPI.MINOR.PATCH
Update MAJORMOD when mod objects (items, blocks, block entities) are removed, fundamental mechanics are changed, or backwards compatibility is broken.
Update MAJORAPI when any part of the mod's public-facing API is changed, such as reordered enums, method signature changes, or removal of public methods.
Update MINOR when mod objects (items, blocks, block entities) or non-fundamental mechanics are added, or elements of the API are deprecated (but not removed)
PATCH will automatically be created by GitHub Action

The value in gradle.properties is only used in local development''')
    }
}

Map<String, Object> getProps(File propFile) {
    Map<String, Object> mappedProps = new HashMap<>()
    Properties props = new Properties()
    if (propFile.canRead()) {
        props.load(new FileInputStream(propFile))
        props.forEach((key, value) -> {
            mappedProps.put(key as String, value)
        })
    }
    return mappedProps
}

task makeChangelogHtml(type: GitChangelogTask) {
    fromRepo = projectDir.absolutePath.toString()
    file = new File ("changelog.html")
    untaggedName = "Current release ${project.version}"
    fromCommit = (System.getenv("GIT_PREVIOUS_SUCCESSFUL_COMMIT") ?: changelogStartCommit)
    toRef =  "HEAD"
    templateContent = file("changelog.mustache").text

    doLast {
        String changeLogText = file('changelog.html').text
        if (releaseType == "alpha" || releaseType == "beta") {
            changeLogText = attachPreReleaseWarning(changeLogText, ChangeLogType.HTML)
        }
        changeLogText = attachReleaseNotes(changeLogText, ChangeLogType.HTML)
        file('changelog.html').setText(changeLogText)
    }
}

task makeChangelogMd(type: GitChangelogTask) {
    fromRepo = projectDir.absolutePath.toString()
    file = new File ("changelog.md")
    untaggedName = "Current release ${project.version}"
    fromCommit = (System.getenv("GIT_PREVIOUS_SUCCESSFUL_COMMIT") ?: changelogStartCommit)
    toRef =  "HEAD"
    templateContent = file("changelog-markdown.mustache").text

    doLast {
        String changeLogText = file('changelog.md').text
        if (releaseType == "alpha" || releaseType == "beta") {
            changeLogText = attachPreReleaseWarning(changeLogText, ChangeLogType.MARKDOWN)
        }
        changeLogText = attachReleaseNotes(changeLogText, ChangeLogType.MARKDOWN)
        file('changelog.md').setText(changeLogText)
    }
}

enum ChangeLogType {
    HTML,
    MARKDOWN
}

String attachReleaseNotes(String changeLogText, ChangeLogType type) {
    if (type == ChangeLogType.HTML) {
        def releaseNotesFile = project.file("docs/release_${modVersion}.html")
        if (releaseNotesFile.exists()) {
            def releaseNotes = releaseNotesFile.getText()
            changeLogText = "$releaseNotes\n<br />\n$changeLogText"
        }
    } else if (type == ChangeLogType.MARKDOWN) {
        def releaseNotesFile = project.file("docs/release_${modVersion}.md")
        if (releaseNotesFile.exists()) {
            def releaseNotes = releaseNotesFile.getText()
            changeLogText = "$releaseNotes\n\n$changeLogText"
        }
    } else {
        println("Could not attach release notes warning to changelog")
    }
    return changeLogText
}

String attachPreReleaseWarning(String changeLogText, ChangeLogType type) {
    if (type == ChangeLogType.HTML) {
        changeLogText = "<strong>Warning: ${projectProperName} is currently in a pre-release state, and is not recommended for widespread use in modpacks. There may be game breaking bugs, " +
        "and updating from one pre-release to the next may cause various ${projectProperName} blocks and items to disappear/void their contents. " +
        "While this is unlikely to happen, make sure to make backups.</strong>\n<br />\n$changeLogText"
    } else if (type == ChangeLogType.MARKDOWN) {
        changeLogText = "**Warning: ${projectProperName} is currently in a pre-release state, and is not recommended for widespread use in modpacks. There may be game breaking bugs, " +
        "and updating from one pre-release to the next may cause various ${projectProperName} blocks and items to disappear/void their contents. " +
        "While this is unlikely to happen, make sure to make backups.**\n\n$changeLogText"
    } else {
        println("Could not attach pre-release warning to changelog")
    }
    return changeLogText
}
