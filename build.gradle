import groovy.json.*

plugins {
    id 'eclipse'
    id 'idea'
    id 'maven-publish'
    id 'java-library'
    id 'com.modrinth.minotaur' version '2.8.7'
    id 'com.matthewprenger.cursegradle' version '1.4.0'
    id 'net.neoforged.gradle.userdev' version '7.0.86'
    id 'com.diffplug.spotless' version '6.23.3'
    id 'org.sonarqube' version '4.4.1.3373'
}

def basicVersion = "${project.mod_version}-build." + getBuildNumber()
version = "${project.minecraft_version}-${basicVersion}" + (basicVersion.endsWith("SNAPSHOT") ?  '' : (project.release_type != 'release' ? "-${project.release_type}" : ''))
group = "novamachina." + project.mod_id

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

base {
    archivesName = project.mod_id
}

sourceSets {
    main {
        java {
            srcDirs = ["src/main/java"]
        }
        resources {
            srcDirs = ["src/main/resources", "src/generated/resources"]
        }
        runs {
            modIdentifier = project.mod_id
        }
    }
}

runs {
    configureEach {
        systemProperty 'forge.logging.markers', 'REGISTRIES'
        systemProperty 'forge.logging.console.level', 'debug'

        modSource project.sourceSets.main
    }
    client {
    }
    server {
    }
    data {
        programArguments.addAll(
                '--mod', project.mod_id,
                '--all',
                '--output', file('src/generated/resources/').getAbsolutePath(),
                '--existing', file('src/main/resources/').getAbsolutePath()
        )
    }
}

repositories {
    mavenLocal()
    maven {
        name 'NovaMachina Mods - Release'
        url 'https://dl.cloudsmith.io/public/novamachina-mods/release/maven/'
        content {
            includeGroup 'novamachina.novacore'
        }
    }
    maven {
        name 'NovaMachina Mods - Snapshot'
        url 'https://dl.cloudsmith.io/public/novamachina-mods/snapshot/maven/'
        content {
            includeGroup 'novamachina.novacore'
        }
    }
}

dependencies {
    implementation "net.neoforged:neoforge:${neo_version}"

    api "novamachina.novacore:novacore:${nova_core_version}"
}

modDependencies = [
        [ modId: "novacore", type: "required", ordering: "AFTER", side: "BOTH", versionRange: novacore_version_range]
]
modMixins = []

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            groupId group
            artifactId System.getenv("MAVEN_ARTIFACT") ?: project.mod_id
            version version
            from components.java
//            artifact jar

            pom {
                name = mod_name
                packaging = 'jar'
                description = mod_description
                scm {
                    url = 'https://github.com/NovaMachina-Mods/' + project.github_id + '.git'
                }
                issueManagement {
                    system = 'github'
                    url = 'https://github.com/NovaMachina-Mods/' + project.github_id + '/issues'
                }
                licenses {
                    license {
                        name = mod_license
                        distribution = 'repo'
                    }
                }
            }
        }
    }
    repositories {
        maven {
            name = "cloudsmith"
            url = "https://maven.cloudsmith.io/novamachina-mods/release/"
            def releaseRepoUrl = "https://maven.cloudsmith.io/novamachina-mods/release/"
            def snapshotRepoUrl = "https://maven.cloudsmith.io/novamachina-mods/snapshot/"
            url = version.endsWith('SNAPSHOT') ? snapshotRepoUrl : releaseRepoUrl
            credentials {
                username = System.getenv("MAVEN_USERNAME")
                password = System.getenv("MAVEN_PASSWORD")
            }
        }
    }
}

sonar {
    properties {
        property "sonar.projectKey", "NovaMachina-Mods_ExNihiloSequentia"
        property "sonar.organization", "novamachina-mods"
        property "sonar.host.url", "https://sonarcloud.io"
    }
}

if(!System.getenv('CI')) {
    apply plugin: com.diffplug.gradle.spotless.SpotlessPlugin
    spotless {
//        ratchetFrom 'origin/1.20'
        format 'misc', {
            target '*.gradle', '*.md', '.gitignore'

            trimTrailingWhitespace()
            indentWithSpaces(2)
            endWithNewline()
        }
        java {
            removeUnusedImports()
            trimTrailingWhitespace()
            googleJavaFormat()
        }
    }
}

project.tasks.named("processResources") {
    outputs.upToDateWhen { false }
    filesMatching('pack.mcmeta') {
        processJsonFile([
                description : mod_name + " resources",
                pack_format : resource_pack_format,
                "forge:resource_pack_format" : resource_pack_format,
                "forge:data_pack_format" : data_pack_format
        ], getFile())
    }
    filesMatching('META-INF/mods.toml') {
        def lines = [
                'modLoader="javafml"',
                'loaderVersion="' + loader_version_range + '"',
                'issueTrackerURL="https://github.com/NovaMachina-Mods/' + project.github_id + '/issues"',
                'license="' + mod_license + '"',
                '',
                '[[mods]]',
                '    modId="' + project.mod_id + '"',
                '    logoFile="' + project.mod_id + '.png"',
                '    version="' + project.mod_version + '"',
                '    displayName="' + project.mod_name + '"',
                '    updateJSONURL="https://api.modrinth.com/updates/' + project.modrinth_project_id + '/forge_updates.json"',
                '    authors="' + project.mod_authors + '"',
                "    description='''" + project.mod_description + "'''",
                '',
                '[[dependencies.' + project.mod_id + ']]',
                '    modId="neoforge"',
                '    type="required"',
                '    versionRange="' + project.neo_version_range + '"',
                '    ordering="NONE"',
                '    side="BOTH"',
                '',
                '[[dependencies.' + project.mod_id + ']]',
                '    modId="minecraft"',
                '    type="required"',
                '    versionRange="' + project.minecraft_version_range + '"',
                '    ordering="NONE"',
                '    side="BOTH"',
                '',
        ]
        if (project.hasProperty("modDependencies")) {
            project.modDependencies.each {
                dependency -> {
                    lines.add('[[dependencies.' + project.mod_id + ']]');
                    dependency.each {
                        entry ->
                            {
                                if (entry.value instanceof Boolean || entry.value instanceof Number) {
                                    lines.add('   ' + entry.key + '=' + entry.value)
                                } else {
                                    lines.add('   ' + entry.key + '="' + entry.value + '"')
                                }
                            }
                    }
                    lines.add('');
                }
            }
        }
        if (project.hasProperty("modMixins") && project.modMixins instanceof List && !project.modMixins.isEmpty()) {
            project.modMixins.each {
                config -> {
                    lines.add('[[mixins]]');
                    lines.add('   config="' + config + '"')
                    lines.add('')
                }
            }
        }

        BufferedWriter writer = new BufferedWriter(new FileWriter(file));
        lines.each {
            line -> {
                writer.write(line)
                writer.newLine()
            }
        }
        writer.close();
    }
}

project.jar {
    manifest {
        attributes([
                "Specification-Title": project.mod_name,
                "Specification-Vendor": "NovaMachina Mods",
                "Specification-Version": project.mod_version,
                "Implementation-Title": project.mod_name,
                "Implementation-Version"  : project.version,
                "Implementation-Vendor": "NovaMachina Mods",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

project.tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

project.tasks.register('upload', GradleBuild) {
    description 'Uploads new version to CurseForge and Modrinth'
    group = 'publishing'
    tasks = ['curseforge', 'modrinth']
}

project.tasks.processResources.dependsOn(project.tasks.compileJava)

project.tasks.register('installLocalGitHook', Copy) {
    group = "management"
    description = "Installs git hooks into their proper location"

    String hooksDir = '.git/hooks'
    if(file("${project.projectDir}/.git").isFile()) {
        String fileContents = new File(project.projectDir, '.git').text
        hooksDir = "${fileContents.split(": ")[1].dropRight(1)}/hooks"
    }

    from new File(project.projectDir, 'scripts/pre-commit')
    into { new File(hooksDir)}
    fileMode 0775
}

project.tasks.build.dependsOn(project.tasks.installLocalGitHook)
project.tasks.build.finalizedBy(project.tasks.publishToMavenLocal)

project.gradle.taskGraph.whenReady {
    if (it.hasTask(project.tasks.modrinth) || it.hasTask(project.tasks.curseforge)) {
        if(!getChangelogText(project)?.trim()) {
            throw new GradleException('No changelog provided')
        }
    }
}

project.tasks.modrinth.enabled = System.getenv("MODRINTH_TOKEN") != null
project.tasks.modrinth.group = 'publishing'
project.modrinth {
    token = System.getenv("MODRINTH_TOKEN")
    if(project.hasProperty("modrinth_id")) {
        projectId = project.modrinth_id
    } else {
        projectId = project.mod_id
    }
    versionNumber = project.mod_version
    versionType = project.release_type
    uploadFile = project.jar
    gameVersions = [ project.minecraft_version ]
    changelog = getChangelogText(project)
    loaders = ["neoforge"]
    dependencies {
        if (project.hasProperty("modDependencies")) {
            project.modDependencies.each {
                dependency -> {
                    if(dependency["type"] == "required") {
                        required.project dependency["modId"]
                    }else if(dependency["type"] == "optional") {
                        optional.project dependency["modId"]
                    }
                }
            }
        }
    }
}

project.tasks.curseforge.enabled = System.getenv("CURSEFORGE_KEY") != null
project.tasks.curseforge.group = 'publishing'
project.curseforge.apiKey = System.getenv("CURSEFORGE_KEY") ?: 'dummy_key'
project.curseforge.project {
    id = project.curseforge_id
    changelog = getChangelogText(project)
    changelogType = "markdown"
    addGameVersion project.minecraft_version
    addGameVersion "NeoForge"
    releaseType = project.release_type
    mainArtifact(project.jar) {}
    if (project.hasProperty("modDependencies") && !project.modDependencies.isEmpty()) {
        relations {
            project.modDependencies.each {
                dependency -> {
                    if(dependency["type"] == "required") {
                        requiredDependency dependency["modId"]
                    }else if(dependency["type"] == "optional") {
                        optionalDependency dependency["modId"]
                    }
                }
            }
        }
    }
}

static String getChangelogText(project) {
    return project.file('CHANGELOG.md').text
}

void processJsonFile(properties, file) {
    String fileContents = file.text.replaceAll(/\$\{[^}]*\}/, "0")
    def input = new JsonSlurper().parseText(fileContents)
    processJson(properties, input)
    BufferedWriter writer = new BufferedWriter(new FileWriter(file));
    writer.write(JsonOutput.prettyPrint(JsonOutput.toJson(input)));
    writer.close();
}

void processJson(properties, object) {
    object.each {
        entry -> {
            if (entry.value instanceof Map) {
                processJson(properties, entry.value)
            } else if (properties.keySet().contains(entry.key)) {
                entry.value = properties.get(entry.key)
                if(entry.value.isNumber()) {
                    entry.value = entry.value.toInteger()
                }
            }
        }
    }
}

static String getBuildNumber() {
    String refName = System.getenv("GITHUB_REF_NAME") ?: "local-build"
    if(refName.endsWith("dev")) {
        return "SNAPSHOT"
    }
    return System.getenv("GITHUB_RUN_NUMBER") ?: "LOCAL"
}
