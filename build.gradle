import net.darkhax.curseforgegradle.TaskPublishCurseForge
import net.darkhax.curseforgegradle.UploadArtifact
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import se.bjurr.gitchangelog.plugin.gradle.GitChangelogTask

buildscript {
    dependencies {
        classpath "com.diffplug.spotless:spotless-plugin-gradle:6.8.0"
    }
}

plugins {
    id 'java'
    id 'idea'
    id 'eclipse'
    id 'maven-publish'
    id 'net.minecraftforge.gradle' version '[6.0,6.2)'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
    id 'net.darkhax.curseforgegradle' version '1.0.11'
    id 'com.modrinth.minotaur' version "2.+"
    id "se.bjurr.gitchangelog.git-changelog-gradle-plugin" version "1.79.0"
}

if(!System.getenv('CI')) {
    apply plugin: 'com.diffplug.spotless'
    spotless {
//        ratchetFrom 'origin/1.20'
        format 'misc', {
            target '*.gradle', '*.md', '.gitignore'

            trimTrailingWhitespace()
            indentWithSpaces(2)
            endWithNewline()
        }
        java {
            removeUnusedImports()
            trimTrailingWhitespace()
            googleJavaFormat()
        }
    }
}

if(project.tasks.findByName("wrapper") == null) {
    task wrapper(type: Wrapper) {
        gradleVersion = '8.1.1'
        distributionType = Wrapper.DistributionType.ALL
    }
}

String minecraftRelease = getMinecraftRelease()

String basicVersion = "${mod_version}." + (System.getenv("GITHUB_RUN_NUMBER") ?: "homebaked")
version = "${minecraft_version}-${basicVersion}" + (release_type != 'release' ? "-${release_type}" : '')
group = mod_group_id
//archivesBaseName = property("artifactBasename")

base {
    archivesName = mod_id
}

defaultTasks 'build'

task installLocalGitHook(type: Copy) {
    group = "management"
    description = "Installs git hooks into their proper location"

    String hooksDir = '.git/hooks'
    if(file("${projectDir}/.git").isFile()) {
        String fileContents = new File(projectDir, '.git').text
        hooksDir = "${fileContents.split(": ")[1].dropRight(1)}/hooks"
    }

    from new File(projectDir, 'scripts/pre-commit')
    into { new File(hooksDir)}
    fileMode 0775
}

build.dependsOn installLocalGitHook

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

println("Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}")
minecraft {
    mappings channel: mappings_channel, version: mappings_version

    copyIdeResources = true

    // accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg') // Currently, this location cannot be changed from the default.

    runs {
        client {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', mod_id
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${mod_id}" {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', mod_id
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${mod_id}" {
                    source sourceSets.main
                }
            }
        }

        gameTestServer {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'forge.enabledGameTestNamespaces', mod_id
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            mods {
                "${mod_id}" {
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            args '--mod', mod_id, '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

            mods {
                "${mod_id}" {
                    source sourceSets.main
                }
            }
        }
    }
}

sourceSets.main.resources { srcDir 'src/generated/resources' }

repositories {
    maven {
        name 'CraftTweaker'
        url "https://maven.blamejared.com"
        content {
            includeGroup 'com.blamejared.crafttweaker'
            includeGroup 'org.openzen.zencode'
            includeGroup 'mezz.jei'
        }
    }
    maven {
        name 'k-4u'
        url 'https://maven.k-4u.nl/'
        content {
            includeGroup 'mcjty.theoneprobe'
        }
    }
    maven {
        name 'CurseMaven'
        url 'https://www.cursemaven.com'
        content {
            includeGroup 'curse.maven'
        }
    }
    maven {
        url 'https://maven.architectury.dev'
        content {
            includeGroup 'dev.architectury'
        }
    }
    maven {
        url 'https://maven.saps.dev/minecraft'
        content {
            includeGroup 'dev.latvian.mods'
        }
    }
    maven {
        name 'NovaMachina Mods'
        url 'https://dl.cloudsmith.io/public/novamachina-mods/ex-nihilo-sequentia/maven/'
        content {
            includeGroup 'novamachina.*'
        }
    }

    whenObjectAdded {
        if (it instanceof MavenArtifactRepository) {
            def url = it.url.toString()
            if (url == 'https://maven.minecraftforge.net/' || url == 'https://libraries.minecraft.net/' || url == 'https://repo.maven.apache.org/maven2/') {
                try {
                    it.content {
                        excludeGroup 'curse.maven'
                        excludeGroup 'mezz.jei'
                        excludeGroup 'mcjty.theoneprobe'
                        excludeGroup 'com.blamejared.crafttweaker'
                        excludeGroup 'dev.architectury'
                        excludeGroup 'dev.latvian.mods'
                        excludeGroup 'novamachina.*'
                    }
                    println("Adding exclusions to ${it.url}")
                } catch (Exception ignored) {
                    //oh well
                }
            }
        }
    }
}

dependencies {
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

    if (findProject(':NovaCore') != null) {
        implementation(project(':NovaCore')) {
            transitive = false
        }
    } else {
        implementation fg.deobf (project.dependencies.create("novamachina.novacore:NovaCore:${nova_core_version}") {
            transitive = false
        })
    }

    if(project.hasProperty("jei_version")) {
        compileOnly fg.deobf("mezz.jei:jei-${minecraft_version}-forge-api:${jei_version}")
        implementation fg.deobf("mezz.jei:jei-${minecraft_version}-forge:${jei_version}")
    }

    if(project.hasProperty("top_version")) {
        compileOnly fg.deobf("mcjty.theoneprobe:theoneprobe:${minecraftRelease}-${top_version}:api") {
            transitive = false
        }
        runtimeOnly fg.deobf("mcjty.theoneprobe:theoneprobe:${minecraftRelease}-${top_version}") {
            transitive = false
        }
    }

    if(project.hasProperty("jade_id")) {
        compileOnly fg.deobf("curse.maven:jade-api-324717:${jade_api_id}")
//        runtimeOnly fg.deobf("curse.maven:jade-324717:${jade_id}")
    }

    if(project.hasProperty("crafttweaker_version")) {
        implementation fg.deobf("com.blamejared.crafttweaker:CraftTweaker-forge-${minecraft_version}:${crafttweaker_version}")
        annotationProcessor 'com.blamejared.crafttweaker:Crafttweaker_Annotation_Processors:3.0.0.10'
        annotationProcessor "net.minecraftforge:forge:${minecraft_version}-${forge_version}"
        annotationProcessor "com.blamejared.crafttweaker:CraftTweaker-forge-${minecraft_version}:${crafttweaker_version}"
    }

    if(project.hasProperty("kubejs_version")) {
        implementation fg.deobf("dev.latvian.mods:kubejs-forge:${kubejs_version}")
        implementation fg.deobf("dev.latvian.mods:rhino-forge:${rhino_version}")
        implementation fg.deobf("dev.architectury:architectury-forge:${architectury_version}")
    }
}

jar {
    manifest {
        attributes([
                "Specification-Title"     : mod_id,
                "Specification-Vendor"    : mod_authors,
                "Specification-Version"   : mod_version,
                "Implementation-Title"    : project.name,
                "Implementation-Version"  : project.jar.archiveVersion,
                "Implementation-Vendor"   : mod_authors,
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

// Example configuration to allow publishing using the maven-publish plugin
// This is the preferred method to reobfuscate your jar file
//jar.finalizedBy('reobfJar')
// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
publish.dependsOn('reobfJar')

tasks.withType(GenerateModuleMetadata) {
    // Disable Gradle 7 module metadata generation as it does not play nicely with FG
    enabled = false
}

publishing {
    publications { PublicationContainer publicationContainer ->
        publicationContainer.register("main", MavenPublication) { MavenPublication publication ->
            publication.from((SoftwareComponent) components.java)
            publication.groupId = project.group
            publication.version = project.version
            publication.artifactId = System.getenv("MAVEN_ARTIFACT") ?: mod_id
            publication.artifacts = [jar]
            publication.pom {
                name.set("${mod_name}")
                packaging = 'jar'
                description.set("${mod_description}")
                url.set("${curseforge_url}")
                scm {
                    url.set("${github_url}.git")
                }
                issueManagement {
                    system.set('github')
                    url.set("${github_url}/issues")
                }
                licenses {
                    license {
                        name.set("${mod_license}")
                        distribution.set('repo')
                    }
                }
                withXml {
                    NodeList dependencies = asNode().dependencies
                    NodeList allDeps = dependencies.'*'

                    // Remove forge deps
                    allDeps.<Node> findAll() { Node el ->
                        el.artifactId.text() == 'forge' && el.groupId.text() == 'net.minecraftforge'
                    }.forEach() { Node el ->
                        el.parent().remove(el)
                    }
                    //remove ForgeGradle's mapped suffix from versions & set as optional so anyone else doesn't inherit them
                    allDeps.<Node> findAll() { Node el ->
                        el.version.text().contains('_mapped_')
                    }.each { Node el ->
                        el.version.each { Node version ->
                            def versionText = version.text()
                            version.setValue(versionText.substring(0, versionText.indexOf('_mapped_')))
                        }
                        el.appendNode('optional', true)
                    }
                }
            }
        }
    }
    repositories {
        maven {
            name = "cloudsmith"
            url = "https://maven.cloudsmith.io/novamachina-mods/ex-nihilo-sequentia/"
            credentials {
                username = System.getenv("MAVEN_USERNAME")
                password = System.getenv("MAVEN_PASSWORD")
            }
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

def resourceTargets = ['META-INF/mods.toml', 'pack.mcmeta']

def replaceProperties = [
        minecraft_version: minecraft_version,
        minecraft_version_range: minecraft_version_range,
        forge_version: forge_version,
        forge_version_range: forge_version_range,
        loader_version_range: loader_version_range,
        mod_id: mod_id,
        mod_name: mod_name,
        mod_license: mod_license,
        mod_version: mod_version,
        mod_authors: mod_authors,
        mod_description: mod_description,
        git_url: github_url,
        curseforge_url: curseforge_url,
//        crafttweaker_version_range: crafttweaker_version_range,
//        jei_version_range : jei_version_range,
//        kubejs_version_range : kubejs_version_range
]

processResources {
    inputs.properties replaceProperties
    replaceProperties.put 'project', project

    filesMatching(resourceTargets) {
        expand replaceProperties
    }

    doLast {
        fileTree(dir: getOutputs().getFiles().getAsPath(), includes: jsonPatterns).each {
            File file -> file.setText(JsonOutput.toJson(new JsonSlurper().parse(file)))
        }
    }
}

compileJava {
    options.compilerArgs << "-Acrafttweaker.processor.document.output_directory=${file('docsOut')}"
    options.getGeneratedSourceOutputDirectory().set(file("src/main/resources/"))
}

String getMinecraftRelease() {
    String value = minecraft_version
    String[] values = value.split("\\.")
    return "${values[0]}.${values[1]}"
}

String getForgeMajor() {
    String value = property("forgeVersion")
    String[] values = value.split("\\.")
    return "${values[0]}"
}

task publishCurseForge(type: TaskPublishCurseForge) {
    group = "publishing"
    description = "Publishes project to CurseForge"

    apiToken = System.getenv("CURSEFORGE_KEY")
    String projectId = curseforge_id

    UploadArtifact mainFile = upload(projectId, jar)
    mainFile.releaseType = release_type
    mainFile.changelogType = 'html'
    mainFile.changelog = (file('changelog.html').exists() ? file('changelog.html').text : "No changelog was specified.")
    mainFile.addModLoader("Forge")
    mainFile.addGameVersion(minecraft_version)
    mainFile.addOptional("jade")
    mainFile.addOptional("jei")
    mainFile.addOptional("the-one-probe")
}

publishCurseForge.dependsOn('reobfJar')
publishCurseForge.dependsOn('makeChangelogHtml')

modrinth {
    token = System.getenv("MODRINTH_TOKEN")
    projectId = modrinth_project_id
    uploadFile = jar
    versionType = release_type
    gameVersions = [minecraft_version]
    loaders = ["forge"]
    changelog = (file('changelog.md').exists() ? file('changelog.md').text : DEFAULT_CHANGELOG)
    dependencies {
        optional.project "jade"
        optional.project "jei"
        optional.project "the-one-probe"
    }
}

//tasks.named("modrinth") {
//    dependsOn('reobfJar')
//}
tasks.named("modrinth") {
    dependsOn('makeChangelogMd')
}

if(rootProject.name != project.name) {
    task updateToolingProperties(type: WriteProperties) {
        group = "management"
        description = "Updates tooling properties for all sub-projects"

        outputs.upToDateWhen {
            false
        }

        outputFile("gradle.properties")

        doFirst {
            def currentProps = getProps(file("gradle.properties"))
            def rootProps = getProps(file("$rootDir/gradle.properties"))

            rootProps.forEach((key, value) -> {
                if (currentProps.containsKey(key)) {
                    currentProps.put(key, value)
                }
            })

            properties(currentProps)
        }

        comment('''This file may have been edited by a Gradle Task.

A note on the 'modVersion' property
Version pattern: MAJORMOD.MAJORAPI.MINOR.PATCH
Update MAJORMOD when mod objects (items, blocks, block entities) are removed, fundamental mechanics are changed, or backwards compatibility is broken.
Update MAJORAPI when any part of the mod's public-facing API is changed, such as reordered enums, method signature changes, or removal of public methods.
Update MINOR when mod objects (items, blocks, block entities) or non-fundamental mechanics are added, or elements of the API are deprecated (but not removed)
PATCH will automatically be created by GitHub Action

The value in gradle.properties is only used in local development''')
    }
}

Map<String, Object> getProps(File propFile) {
    Map<String, Object> mappedProps = new HashMap<>()
    Properties props = new Properties()
    if (propFile.canRead()) {
        props.load(new FileInputStream(propFile))
        props.forEach((key, value) -> {
            mappedProps.put(key as String, value)
        })
    }
    return mappedProps
}

task makeChangelogHtml(type: GitChangelogTask) {
    fromRepo = projectDir.absolutePath.toString()
    file = new File ("changelog.html")
    untaggedName = "Current release ${project.version}"
    fromCommit = (System.getenv("GIT_PREVIOUS_SUCCESSFUL_COMMIT") ?: changelog_start_commit)
    toRef =  "HEAD"
    templateContent = file("changelog.mustache").text

    doLast {
        String changeLogText = file('changelog.html').text
        if (release_type == "alpha" || release_type == "beta") {
            changeLogText = attachPreReleaseWarning(changeLogText, ChangeLogType.HTML)
        }
        changeLogText = attachReleaseNotes(changeLogText, ChangeLogType.HTML)
        file('changelog.html').setText(changeLogText)
    }
}

task makeChangelogMd(type: GitChangelogTask) {
    fromRepo = projectDir.absolutePath.toString()
    file = new File ("changelog.md")
    untaggedName = "Current release ${project.version}"
    fromCommit = (System.getenv("GIT_PREVIOUS_SUCCESSFUL_COMMIT") ?: changelog_start_commit)
    toRef =  "HEAD"
    templateContent = file("changelog-markdown.mustache").text

    doLast {
        String changeLogText = file('changelog.md').text
        if (release_type == "alpha" || release_type == "beta") {
            changeLogText = attachPreReleaseWarning(changeLogText, ChangeLogType.MARKDOWN)
        }
        changeLogText = attachReleaseNotes(changeLogText, ChangeLogType.MARKDOWN)
        file('changelog.md').setText(changeLogText)
    }
}

enum ChangeLogType {
    HTML,
    MARKDOWN
}

String attachReleaseNotes(String changeLogText, ChangeLogType type) {
    if (type == ChangeLogType.HTML) {
        def releaseNotesFile = project.file("docs/release_${mod_version}.html")
        if (releaseNotesFile.exists()) {
            def releaseNotes = releaseNotesFile.getText()
            changeLogText = "$releaseNotes\n<br />\n$changeLogText"
        }
    } else if (type == ChangeLogType.MARKDOWN) {
        def releaseNotesFile = project.file("docs/release_${mod_version}.md")
        if (releaseNotesFile.exists()) {
            def releaseNotes = releaseNotesFile.getText()
            changeLogText = "$releaseNotes\n\n$changeLogText"
        }
    } else {
        println("Could not attach release notes warning to changelog")
    }
    return changeLogText
}

String attachPreReleaseWarning(String changeLogText, ChangeLogType type) {
    if (type == ChangeLogType.HTML) {
        changeLogText = "<strong>Warning: ${mod_name} is currently in a pre-release state, and is not recommended for widespread use in modpacks. There may be game breaking bugs, " +
                "and updating from one pre-release to the next may cause various ${mod_name} blocks and items to disappear/void their contents. " +
                "While this is unlikely to happen, make sure to make backups.</strong>\n<br />\n$changeLogText"
    } else if (type == ChangeLogType.MARKDOWN) {
        changeLogText = "**Warning: ${mod_name} is currently in a pre-release state, and is not recommended for widespread use in modpacks. There may be game breaking bugs, " +
                "and updating from one pre-release to the next may cause various ${mod_name} blocks and items to disappear/void their contents. " +
                "While this is unlikely to happen, make sure to make backups.**\n\n$changeLogText"
    } else {
        println("Could not attach pre-release warning to changelog")
    }
    return changeLogText
}
